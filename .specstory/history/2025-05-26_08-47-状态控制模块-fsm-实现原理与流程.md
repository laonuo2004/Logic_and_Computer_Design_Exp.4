<!-- Generated by SpecStory -->

# 状态控制模块 - FSM 实现原理与流程 (2025-05-26 16:47:35)

_**User**_

解释**状态控制模块 - FSM**的实现原理与流程

---

_**Assistant**_



---

好的，我们来分析一下 `state_controller.v` 文件中定义的状态控制模块（FSM - Finite State Machine，有限状态机）的实现原理与流程。

**1. 模块功能 (Purpose)**

该模块 `state_controller` 的主要功能是实现一个短跑计时器的核心控制逻辑。它通过一个状态机来管理计时器的各种工作模式，包括：空闲、运行、暂停和报警。它根据外部按键输入和计时器自身的状态（如达到最大计时时间）来切换状态，并输出相应的控制信号给计时器模块和报警模块。

**2. 输入与输出 (Inputs/Outputs)**

*   **输入 (Inputs):**
    *   `clk`: 系统时钟信号，用于驱动状态机的时序逻辑。
    *   `reset_n`: 异步复位信号（低电平有效）。当此信号为低时，状态机强制进入 `S_IDLE` 状态。
    *   `key_a_pulse`: 按键 A 的脉冲信号。通常用于“开始”或“继续”计时。
    *   `key_b_pulse`: 按键 B 的脉冲信号。通常用于“停止”或“暂停”计时。
    *   `key_c_pulse`: 按键 C 的脉冲信号。通常用于“复位”计时器或在报警状态下清除报警。
    *   `max_time_reached_in`: 最大计时时间到达信号。当计时器计数达到预设的最大值时，此信号有效。

*   **输出 (Outputs):**
    *   `timer_run_en_out`: 计时器运行使能信号。当此信号为高时，计时器开始或继续计数。
    *   `timer_reset_cmd_out`: 计时器复位命令（高电平有效）。当此信号为高时，计时器被清零。
    *   `alarm_active_out`: 报警激活信号。当此信号为高时，表示计时器进入报警状态（例如，时间到）。

**3. 状态定义 (States)**

状态机定义了以下四种状态：

*   `S_IDLE` (2'b00): 空闲/复位状态。计时器停止，并等待开始命令。在此状态下，计时器会被持续复位。
*   `S_RUNNING` (2'b01): 计时运行状态。计时器正在计数。
*   `S_PAUSED` (2'b10): 计时暂停状态。计时器暂停计数，但当前计数值保持不变。
*   `S_ALARM` (2'b11): 报警状态。通常在计时达到最大值时进入此状态。

**4. 状态机结构**

该状态机是典型的 **Moore型状态机**（尽管输出逻辑中对 `timer_reset_cmd_out` 的处理略微灵活，使其在 `S_IDLE` 状态下持续有效，而不严格依赖时钟边沿后的状态切换）。它主要由三部分组成：

*   **状态寄存器 (State Register):**
    *   `current_state`: 一个2位寄存器，存储状态机的当前状态。
    *   它的更新是**时序逻辑**，在 `clk` 的上升沿或 `reset_n` 的下降沿触发。
    *   如果 `reset_n` 为低，`current_state` 被强制设为 `S_IDLE`。
    *   否则，`current_state` 在时钟上升沿更新为 `next_state` 的值。

    ```verilog
    always @(posedge clk or negedge reset_n) begin
        if (!reset_n) begin
            current_state <= S_IDLE;
        end else begin
            current_state <= next_state;
        end
    end
    ```

*   **次态逻辑 (Next State Logic):**
    *   `next_state`: 一个2位寄存器（在 `always @(*)` 块中实际表现为组合逻辑的输出），用于计算状态机的下一个状态。
    *   这部分是**组合逻辑**，它的值根据 `current_state` 和当前的输入信号（`key_a_pulse`, `key_b_pulse`, `key_c_pulse`, `max_time_reached_in`）立即确定。
    *   它使用一个 `case` 语句来描述在每种当前状态下，响应不同输入时应该跳转到哪个下一状态。
    *   默认情况下，`next_state` 被赋值为 `current_state`，表示如果没有特定条件满足状态转换，则保持当前状态。

    ```verilog
    always @(*) begin
        next_state = current_state; // 默认保持当前状态
        case (current_state)
            S_IDLE: begin
                if (key_a_pulse) begin
                    next_state = S_RUNNING;
                end
                // 按下C在IDLE状态下保持IDLE，复位命令已在输出逻辑中处理
            end
            S_RUNNING: begin
                if (key_b_pulse) begin // 按键B: 暂停
                    next_state = S_PAUSED;
                end else if (key_c_pulse) begin // 按键C: 复位到IDLE
                    next_state = S_IDLE;
                end else if (max_time_reached_in) begin // 时间到: 报警
                    next_state = S_ALARM;
                end
            end
            S_PAUSED: begin
                if (key_a_pulse) begin // 按键A: 继续运行
                    next_state = S_RUNNING;
                end else if (key_c_pulse) begin // 按键C: 复位到IDLE
                    next_state = S_IDLE;
                end
            end
            S_ALARM: begin
                if (key_c_pulse) begin // 按键C: 清除报警，回到IDLE
                    next_state = S_IDLE;
                end
            end
            default: begin // 安全状态，任何未知状态都回到IDLE
                next_state = S_IDLE;
            end
        endcase
    end
    ```

*   **输出逻辑 (Output Logic):**
    *   这部分也是**组合逻辑**，它根据 `current_state` 来决定输出信号 `timer_run_en_out`, `timer_reset_cmd_out`, 和 `alarm_active_out` 的值。
    *   Moore型状态机的输出通常只依赖于当前状态。
    *   默认情况下，所有输出都设置为非活动状态（`timer_run_en_out = 0`, `timer_reset_cmd_out = 0`, `alarm_active_out = 0`）。
    *   然后使用 `case` 语句根据 `current_state` 设置相应的输出：
        *   `S_IDLE`: 计时器不运行 (`timer_run_en_out = 0`)，持续请求复位计时器 (`timer_reset_cmd_out = 1`)，报警关闭 (`alarm_active_out = 0`)。
        *   `S_RUNNING`: 计时器运行 (`timer_run_en_out = 1`)，不复位 (`timer_reset_cmd_out = 0`)，报警关闭。
        *   `S_PAUSED`: 计时器不运行，不复位，报警关闭。
        *   `S_ALARM`: 计时器不运行，不复位，报警激活 (`alarm_active_out = 1`)。

    ```verilog
    always @(*) begin
        // 默认输出
        timer_run_en_out    = 1'b0;
        timer_reset_cmd_out = 1'b0;
        alarm_active_out    = 1'b0;

        case (current_state)
            S_IDLE: begin
                timer_run_en_out    = 1'b0;
                timer_reset_cmd_out = 1'b1;
                alarm_active_out    = 1'b0;
            end
            // ... 其他状态的输出设置 ...
            S_ALARM: begin
                timer_run_en_out    = 1'b0;
                timer_reset_cmd_out = 1'b0;
                alarm_active_out    = 1'b1;
            end
            default: begin // 安全起见，默认行为同IDLE
                timer_run_en_out    = 1'b0;
                timer_reset_cmd_out = 1'b1;
                alarm_active_out    = 1'b0;
            end
        endcase
    end
    ```

**5. 工作流程 (Flow of Operation)**

1.  **复位 (Reset):** 当 `reset_n` 信号为低电平时，状态机异步复位到 `S_IDLE` 状态。在 `S_IDLE` 状态，`timer_reset_cmd_out` 输出高电平，使计时器清零。`timer_run_en_out` 为低，计时器不工作。

2.  **从 IDLE 开始计时:**
    *   在 `S_IDLE` 状态，如果检测到 `key_a_pulse` (按键A按下)，状态机在下一个时钟上升沿转换到 `S_RUNNING` 状态。
    *   进入 `S_RUNNING` 状态后，`timer_run_en_out` 变为高电平，使能计时器开始计数。`timer_reset_cmd_out` 变为低电平。

3.  **运行中 (S_RUNNING):**
    *   **暂停 (Pause):** 如果在 `S_RUNNING` 状态检测到 `key_b_pulse` (按键B按下)，状态机转换到 `S_PAUSED` 状态。在 `S_PAUSED` 状态，`timer_run_en_out` 变为低电平，计时器暂停计数。
    *   **复位 (Reset):** 如果在 `S_RUNNING` 状态检测到 `key_c_pulse` (按键C按下)，状态机转换回 `S_IDLE` 状态，计时器将被复位。
    *   **时间到 (Max Time Reached):** 如果在 `S_RUNNING` 状态，`max_time_reached_in` 信号变为高电平，表示计时达到最大值，状态机转换到 `S_ALARM` 状态。

4.  **暂停中 (S_PAUSED):**
    *   **继续 (Continue):** 如果在 `S_PAUSED` 状态检测到 `key_a_pulse` (按键A按下)，状态机转换回 `S_RUNNING` 状态，计时器从暂停处继续计数。
    *   **复位 (Reset):** 如果在 `S_PAUSED` 状态检测到 `key_c_pulse` (按键C按下)，状态机转换到 `S_IDLE` 状态，计时器将被复位。

5.  **报警中 (S_ALARM):**
    *   在 `S_ALARM` 状态，`alarm_active_out` 输出高电平，激活报警。计时器停止 (`timer_run_en_out` 为低)。
    *   **清除报警/复位 (Clear Alarm/Reset):** 如果

---

